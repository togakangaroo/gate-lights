<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acrylic Rod Lighting Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #d3d3d3;
            color: #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        .info {
            margin-bottom: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .simulator-container {
            background: #e8e8e8;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .rods-container {
            display: flex;
            align-items: flex-end;
            gap: 60px; /* 6 inches * 10px per inch = 60px */
            padding: 20px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .rod-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .rod {
            width: 16px; /* 5px looks more accurate, but this is a better visualization */
            height: 600px; /* 5 feet * 12 inches/foot * 10px per inch = 600px */
            background: transparent;
            border: 1px solid #000;
            border-radius: 2px;
            box-shadow: none;
            transition: all 0.3s ease;
        }

        .rod:hover {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .led-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-label {
            font-size: 10px;
            color: #666;
            user-select: none;
        }

        .specs {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
        }

        .control-panel {
            margin-top: 30px;
            padding: 20px;
            background: #e8e8e8;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .control-panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
        }

        .pattern-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .pattern-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .pattern-option input[type="radio"] {
            cursor: pointer;
        }

        .pattern-option label {
            cursor: pointer;
            user-select: none;
        }
    </style>
</head>
<body>
    <h1>Acrylic Rod Lighting Simulator</h1>

    <div class="info">
        <p style="max-width: 600px; margin: 0 auto 15px; line-height: 1.5;">
            This simulator represents an art installation featuring vertical acrylic rods with LED lights at each end.
            Use the checkboxes to toggle lights on and off, experimenting with different patterns to visualize how the illuminated rods will look in the final display.
        </p>
        <div>6 acrylic rods: 5ft tall Ã— 0.5" wide, spaced 6" apart</div>
        <div class="specs">Scale: 10px = 1 inch</div>
    </div>

    <div class="simulator-container">
        <div class="rods-container" id="rodsContainer">
            <div class="rod-wrapper">
                <input type="checkbox" class="led-checkbox" data-light="1" data-rod="1" data-end="top" id="led-1">
                <div class="rod" data-rod="1"></div>
                <input type="checkbox" class="led-checkbox" data-light="7" data-rod="1" data-end="bottom" id="led-7">
            </div>
            <div class="rod-wrapper">
                <input type="checkbox" class="led-checkbox" data-light="2" data-rod="2" data-end="top" id="led-2">
                <div class="rod" data-rod="2"></div>
                <input type="checkbox" class="led-checkbox" data-light="8" data-rod="2" data-end="bottom" id="led-8">
            </div>
            <div class="rod-wrapper">
                <input type="checkbox" class="led-checkbox" data-light="3" data-rod="3" data-end="top" id="led-3">
                <div class="rod" data-rod="3"></div>
                <input type="checkbox" class="led-checkbox" data-light="9" data-rod="3" data-end="bottom" id="led-9">
            </div>
            <div class="rod-wrapper">
                <input type="checkbox" class="led-checkbox" data-light="4" data-rod="4" data-end="top" id="led-4">
                <div class="rod" data-rod="4"></div>
                <input type="checkbox" class="led-checkbox" data-light="10" data-rod="4" data-end="bottom" id="led-10">
            </div>
            <div class="rod-wrapper">
                <input type="checkbox" class="led-checkbox" data-light="5" data-rod="5" data-end="top" id="led-5">
                <div class="rod" data-rod="5"></div>
                <input type="checkbox" class="led-checkbox" data-light="11" data-rod="5" data-end="bottom" id="led-11">
            </div>
            <div class="rod-wrapper">
                <input type="checkbox" class="led-checkbox" data-light="6" data-rod="6" data-end="top" id="led-6">
                <div class="rod" data-rod="6"></div>
                <input type="checkbox" class="led-checkbox" data-light="12" data-rod="6" data-end="bottom" id="led-12">
            </div>
        </div>
    </div>

    <div class="control-panel">
        <h2>Patterns</h2>
        <div class="pattern-options">
            <div class="pattern-option">
                <input type="radio" id="pattern-none" name="pattern" value="none" checked>
                <label for="pattern-none">None</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-all-random" name="pattern" value="all-random">
                <label for="pattern-all-random">All (Random)</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-bounce" name="pattern" value="bounce">
                <label for="pattern-bounce">Bounce</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-random" name="pattern" value="random">
                <label for="pattern-random">Random</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-wave" name="pattern" value="wave">
                <label for="pattern-wave">Wave</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-snake" name="pattern" value="snake">
                <label for="pattern-snake">Snake</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-sparkle" name="pattern" value="sparkle">
                <label for="pattern-sparkle">Sparkle</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-waterfall" name="pattern" value="waterfall">
                <label for="pattern-waterfall">Waterfall</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-swizzle" name="pattern" value="swizzle">
                <label for="pattern-swizzle">Swizzle</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-breathing" name="pattern" value="breathing">
                <label for="pattern-breathing">Breathing</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-rule30" name="pattern" value="rule30">
                <label for="pattern-rule30">Rule 30 (Cellular Automaton)</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-variable-rule30" name="pattern" value="variableRule30">
                <label for="pattern-variable-rule30">Rule 30 (Variable Rate)</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-langton" name="pattern" value="langton">
                <label for="pattern-langton">Langton's Ant</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-inverted-ant" name="pattern" value="inverted-ant">
                <label for="pattern-inverted-ant">Inverted Ant</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-heartbeat" name="pattern" value="heartbeat">
                <label for="pattern-heartbeat">Heartbeat</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-thunder" name="pattern" value="thunder">
                <label for="pattern-thunder">Thunder</label>
            </div>
            <div class="pattern-option">
                <input type="radio" id="pattern-explosion" name="pattern" value="explosion">
                <label for="pattern-explosion">Explosion</label>
            </div>
        </div>
    </div>

    <script>
        const rods = document.querySelectorAll('.rod');
        const ledCheckboxes = document.querySelectorAll('.led-checkbox');

        // Bright green LED color
        const LED_COLOR = { r: 0, g: 255, b: 0 };

        // Light state: tracks which lights are on
        const lightState = {};

        const bouncePatternTemplate = function*() {
            while(true) {
                // Moving right
                yield `000000
                       100000`
                yield `000000
                       010000`
                yield `000000
                       001000`
                yield `000000
                       000100`
                yield `000000
                       000010`
                yield `000000
                       000001`
                // Moving left
                yield `000000
                       000010`
                yield `000000
                       000100`
                yield `000000
                       001000`
                yield `000000
                       010000`
            }
        }

        const randomPatternTemplate = function*() {
            while(true) {
                // Pick a random number of lights (0-12)
                const numLights = Math.floor(Math.random() * 13);

                // Create array of all light positions [0-11]
                const allLights = Array.from({length: 12}, (_, i) => i);

                // Shuffle using Fisher-Yates
                for (let i = allLights.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allLights[i], allLights[j]] = [allLights[j], allLights[i]];
                }

                // Create pattern string
                let topRow = ['0', '0', '0', '0', '0', '0'];
                let bottomRow = ['0', '0', '0', '0', '0', '0'];

                for (let i = 0; i < numLights; i++) {
                    const lightIndex = allLights[i];
                    if (lightIndex < 6) {
                        topRow[lightIndex] = '1';
                    } else {
                        bottomRow[lightIndex - 6] = '1';
                    }
                }

                yield `${topRow.join('')}
                       ${bottomRow.join('')}`;
            }
        }

        const wavePatternTemplate = function*() {
            while(true) {
                // Moving right
                yield [`100000
                        110000`, 350]
                yield [`010000
                        111000`, 200]
                yield [`001000
                        111100`, 200]
                yield [`000100
                        011110`, 200]
                yield [`000010
                        001111`, 200]
                yield [`000001
                        000111`, 200]
                yield [`000001
                        000011`, 350]
                // Moving left
                yield [`000010
                        000111`, 200]
                yield [`000100
                        001111`, 200]
                yield [`001000
                        011110`, 200]
                yield [`010000
                        111100`, 200]
                yield [`100000
                        111000`, 200]
            }
        }

        const snakePatternTemplate = function*() {
            while(true) {
                yield `111100
                       000100`
                yield `011110
                       000010`
                yield `001111
                       000001`
                yield `000111
                       000001`
                yield `000011
                       000011`
                yield `000101
                       000111`
                yield `001000
                       001111`
                yield `010000
                       011110`
                yield `100000
                       111100`
                yield `100000
                       111000`
                yield `110000
                       110000`
                yield `111000
                       101000`
            }
        }

        const sparklePatternTemplate = function*() {
            while(true) {
                // Create 1-3 random sparkles
                const numSparkles = Math.floor(Math.random() * 3) + 1;
                const allPositions = Array.from({length: 12}, (_, i) => i);

                // Shuffle
                for (let i = allPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                }

                let topRow = ['0', '0', '0', '0', '0', '0'];
                let bottomRow = ['0', '0', '0', '0', '0', '0'];

                for (let i = 0; i < numSparkles; i++) {
                    const pos = allPositions[i];
                    if (pos < 6) {
                        topRow[pos] = '1';
                    } else {
                        bottomRow[pos - 6] = '1';
                    }
                }

                yield `${topRow.join('')}
                       ${bottomRow.join('')}`;
            }
        }

     const swizzlePatternTemplate = function*() {
            while(true) {
                yield `110111
                       011101`
                yield `111011
                       101110`
                yield `111101
                       010111`
                yield `111110
                       101011`
                yield `011111
                       110101`
                yield `101111
                       111010`
            }
     }

        const waterfallPatternTemplate = function*() {
            while(true) {
                // Cascade from left to right, top to bottom
                yield `100000
                       000000`
                yield `110000
                       100000`
                yield `111000
                       110000`
                yield `111100
                       111000`
                yield `111110
                       111100`
                yield `111111
                       111110`
                yield `011111
                       111111`
                yield `001111
                       011111`
                yield `000111
                       001111`
                yield `000011
                       000111`
                yield `000001
                       000011`
                yield `000000
                       000001`
                yield `000000
                       000000`
            }
        }

        const breathingPatternTemplate = function*() {
            while(true) {
                // Breathing in - gradually light up all lights
                yield `000000
                       000000`
                yield `000000
                       010000`
                yield `000000
                       011000`
                yield `010000
                       011000`
                yield `011000
                       011100`
                yield `011000
                       111100`
                yield `011100
                       111100`
                yield `111100
                       111110`
                yield `111100
                       111111`
                yield `111110
                       111111`
                yield `111111
                       111111`
                // Hold
                yield `111111
                       111111`
                yield `111111
                       111111`
                // Breathing out - gradually turn off
                yield `111110
                       111111`
                yield `111100
                       111111`
                yield `111100
                       111110`
                yield `111100
                       111100`
                yield `011100
                       111100`
                yield `011000
                       111100`
                yield `011000
                       011100`
                yield `010000
                       011000`
                yield `000000
                       011000`
                yield `000000
                       010000`
                yield `000000
                       000000`
                // Hold
                yield `000000
                       000000`
                yield `000000
                       000000`
            }
        }

        // Rule 30 - Elementary Cellular Automaton
        // Famous for producing complex, chaotic patterns from simple rules
        const rule30PatternTemplate = function*() {
            let grid = [
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 0, 0]  // Start with single cell in middle
            ];

            let lastState = null;

            while(true) {
                // Convert grid to string
                const topStr = grid[0].join('');
                const bottomStr = grid[1].join('');
                const currentState = `${topStr}${bottomStr}`;

                yield `${topStr}
                       ${bottomStr}`;

                // Evolve bottom row according to Rule 30
                const newBottom = [];
                for (let i = 0; i < 6; i++) {
                    const left = grid[1][(i - 1 + 6) % 6];   // Wrap around
                    const center = grid[1][i];
                    const right = grid[1][(i + 1) % 6];      // Wrap around

                    // Rule 30: 111->0, 110->0, 101->0, 100->1, 011->1, 010->1, 001->1, 000->0
                    const pattern = (left << 2) | (center << 1) | right;
                    const newVal = (30 >> pattern) & 1;
                    newBottom[i] = newVal;
                }

                // Shift: top becomes old bottom, bottom becomes new generation
                grid[0] = [...grid[1]];
                grid[1] = newBottom;

                // Reset if pattern is stuck (same as last step)
                const newState = `${grid[0].join('')}${grid[1].join('')}`;
                if (newState === lastState) {
                    // Yield the stuck state once
                    yield `${grid[0].join('')}
                           ${grid[1].join('')}`;

                    // Reset with random starting position
                    const newGrid = [
                        [0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0]
                    ];

                    // Turn on 1-3 random cells in bottom row
                    const numCells = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < numCells; i++) {
                        const randomCol = Math.floor(Math.random() * 6);
                        newGrid[1][randomCol] = 1;
                    }

                    grid = newGrid;
                    lastState = null;
                } else {
                    lastState = currentState;
                }
            }
        }

        const variableRule30PatternTemplate = function *() {
            const rule30 = rule30PatternTemplate()
            const count = (val, coll) => Array.from(coll).filter(x => x === val).length
            for(const pattern of rule30) {
                const lines = pattern.split('\n')
                let timing = 100 * (count('1', lines[1]) - count('1', lines[0]))
                timing = timing < 0 ? 0 : timing
                timing += 200
                yield [pattern, timing]
            }
        }

        // Thunder - Random lightning flashes with variable delays simulating a storm
        const thunderPatternTemplate = function*() {
            while(true) {
                // Lightning flash - full brightness
                yield [`111111
                        111111`, 80];

                // Quick second flash (sometimes lightning strikes twice)
                if (Math.random() < 0.3) {
                    yield [`000000
                            000000`, 50];
                    yield [`111111
                            111111`, 80];
                }

                // Darkness
                yield [`000000
                        000000`, 200];

                // Variable pause before next strike (1-4 seconds)
                const pause = 1000 + Math.random() * 3000;
                yield [`000000
                        000000`, pause];
            }
        }

        // Explosion - Expands outward from center with accelerating speed
        const explosionPatternTemplate = function*() {
            while(true) {
                // Darkness before next explosion
                yield [`000000
                        000000`, 800];

                // Ignition - center lights up
                yield [`000000
                        001100`, 150];

                // Rapid expansion
                yield [`001100
                        011110`, 100];

                yield [`011110
                        111111`, 80];

                // Full blast
                yield [`111111
                        111111`, 60];

                // Flash
                yield [`111111
                        111111`, 40];

                // Fade slowly - dust settling
                yield [`011110
                        111111`, 200];

                yield [`001100
                        011110`, 300];

                yield [`000000
                        011110`, 300];

                yield [`000000
                        001100`, 400];

            }
        }

        // Langton's Ant - Simple rules create complex emergent behavior
        // Ant turns left on 1, right on 0, and flips the cell
        // Simulates on larger 6x12 grid, displays 2x6 window following the ant
        const langtonsAntPatternTemplate = function*() {
            const GRID_ROWS = 6;
            const GRID_COLS = 12;
            const DISPLAY_ROWS = 2;
            const DISPLAY_COLS = 6;

            let grid = Array(GRID_ROWS).fill(0).map(() => Array(GRID_COLS).fill(0));

            let antRow = Math.floor(Math.random() * GRID_ROWS);
            let antCol = Math.floor(Math.random() * GRID_COLS);
            let antDir = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left

            while(true) {
                // Calculate display window centered on ant
                let displayStartRow = Math.max(0, Math.min(GRID_ROWS - DISPLAY_ROWS, antRow - Math.floor(DISPLAY_ROWS / 2)));
                let displayStartCol = Math.max(0, Math.min(GRID_COLS - DISPLAY_COLS, antCol - Math.floor(DISPLAY_COLS / 2)));

                // Extract 2x6 window
                const displayGrid = [];
                for (let r = 0; r < DISPLAY_ROWS; r++) {
                    displayGrid[r] = [];
                    for (let c = 0; c < DISPLAY_COLS; c++) {
                        displayGrid[r][c] = grid[displayStartRow + r][displayStartCol + c];
                    }
                }

                // Show ant position if it's in the display window
                const antDisplayRow = antRow - displayStartRow;
                const antDisplayCol = antCol - displayStartCol;
                if (antDisplayRow >= 0 && antDisplayRow < DISPLAY_ROWS &&
                    antDisplayCol >= 0 && antDisplayCol < DISPLAY_COLS) {
                    displayGrid[antDisplayRow][antDisplayCol] = 1;
                }

                const topStr = displayGrid[0].join('');
                const bottomStr = displayGrid[1].join('');
                yield `${topStr}
                       ${bottomStr}`;

                // Apply Langton's Ant rules
                const currentCell = grid[antRow][antCol];

                if (currentCell === 0) {
                    // Turn right (clockwise)
                    antDir = (antDir + 1) % 4;
                } else {
                    // Turn left (counter-clockwise)
                    antDir = (antDir + 3) % 4;
                }

                // Flip current cell
                grid[antRow][antCol] = 1 - currentCell;

                // Move forward with wrapping on larger grid
                if (antDir === 0) antRow = (antRow - 1 + GRID_ROWS) % GRID_ROWS;      // up
                else if (antDir === 1) antCol = (antCol + 1) % GRID_COLS;             // right
                else if (antDir === 2) antRow = (antRow + 1) % GRID_ROWS;             // down
                else if (antDir === 3) antCol = (antCol - 1 + GRID_COLS) % GRID_COLS; // left
            }
        }

        // Inverted Langton's Ant - Rules reversed: turn left on 0, right on 1
        const invertedAntPatternTemplate = function*() {
            ant = langtonsAntPatternTemplate()
            for(const s of ant)
                yield s.replaceAll('0','p').replaceAll('1', '0').replaceAll('p', '1')
        }

        // Heartbeat - Demonstrates variable timing with realistic heartbeat pattern
        const heartbeatPatternTemplate = function*() {
            while(true) {
                // First beat (systole) - quick flash from center outward
                yield [`000000
                        001100`, 100];
                yield [`001100
                        011110`, 100];
                yield [`011110
                        111111`, 150];

                // Brief pause
                yield [`000000
                        000000`, 100];

                // Second beat (diastole) - slightly weaker
                yield [`000000
                        001100`, 100];
                yield [`001100
                        011110`, 150];

                // Longer pause before next heartbeat
                yield [`000000
                        000000`, 600];
            }
        }

        // All (Random) - Cycles through random patterns every 24 steps
        const allRandomPatternTemplate = function*() {
            // List of all pattern generator functions
            const patternGenerators = [
                bouncePatternTemplate,
                randomPatternTemplate,
                wavePatternTemplate,
                snakePatternTemplate,
                sparklePatternTemplate,
                waterfallPatternTemplate,
                swizzlePatternTemplate,
                breathingPatternTemplate,
                rule30PatternTemplate,
                variableRule30PatternTemplate,
                langtonsAntPatternTemplate,
                invertedAntPatternTemplate,
                heartbeatPatternTemplate,
                thunderPatternTemplate,
                explosionPatternTemplate
            ];

            while(true) {
                // Pick a random pattern
                const randomIndex = Math.floor(Math.random() * patternGenerators.length);
                const patternGen = patternGenerators[randomIndex]();

                // Run it for 24 steps
                for (let i = 0; i < 24; i++) {
                    const result = patternGen.next();
                    if (result.done) break;
                    yield result.value;
                }
            }
        }

        // Map light number to rod and end
        function getLightInfo(lightNumber) {
            // Lights 1-6 are top (rods 1-6)
            // Lights 7-12 are bottom (rods 1-6)
            if (lightNumber >= 1 && lightNumber <= 6) {
                return { rod: lightNumber, end: 'top' };
            } else if (lightNumber >= 7 && lightNumber <= 12) {
                return { rod: lightNumber - 6, end: 'bottom' };
            }
            return null;
        }

        // Toggle a light on or off
        function toggle(lightNumber, isOn) {
            lightState[lightNumber] = isOn;

            const info = getLightInfo(lightNumber);
            if (!info) return;

            const rodElement = document.querySelector(`.rod[data-rod="${info.rod}"]`);
            updateRodGradient(rodElement, info.rod);

            // Update checkbox to match light state
            const checkbox = document.querySelector(`#led-${lightNumber}`);
            if (checkbox) {
                checkbox.checked = isOn;
            }
        }

        function updateRodGradient(rodElement, rodNum) {
            // Find which lights are on for this rod
            const topLight = rodNum; // Lights 1-6
            const bottomLight = rodNum + 6; // Lights 7-12

            const topLit = lightState[topLight] || false;
            const bottomLit = lightState[bottomLight] || false;

            if (!topLit && !bottomLit) {
                // No LEDs lit - transparent
                rodElement.style.background = 'transparent';
            } else if (topLit && !bottomLit) {
                // Top LED lit - gradient from top (70% opacity) to bottom (0% opacity)
                rodElement.style.background = `linear-gradient(to bottom,
                    rgba(${LED_COLOR.r}, ${LED_COLOR.g}, ${LED_COLOR.b}, 0.7),
                    rgba(${LED_COLOR.r}, ${LED_COLOR.g}, ${LED_COLOR.b}, 0))`;
            } else if (!topLit && bottomLit) {
                // Bottom LED lit - gradient from bottom (70% opacity) to top (0% opacity)
                rodElement.style.background = `linear-gradient(to top,
                    rgba(${LED_COLOR.r}, ${LED_COLOR.g}, ${LED_COLOR.b}, 0.7),
                    rgba(${LED_COLOR.r}, ${LED_COLOR.g}, ${LED_COLOR.b}, 0))`;
            } else {
                // Both LEDs lit - bright at both ends, transparent in middle
                rodElement.style.background = `linear-gradient(to bottom,
                    rgba(${LED_COLOR.r}, ${LED_COLOR.g}, ${LED_COLOR.b}, 0.7) 0%,
                    rgba(${LED_COLOR.r}, ${LED_COLOR.g}, ${LED_COLOR.b}, 0.7) 100%)`;
            }
        }

        // Add event listeners to LED checkboxes
        ledCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const lightNumber = parseInt(e.target.dataset.light);
                toggle(lightNumber, e.target.checked);
            });
        });

        // Initialize light state
        for (let i = 1; i <= 12; i++) {
            lightState[i] = false;
        }

        // Initialize all rod gradients
        rods.forEach(rod => {
            const rodNum = parseInt(rod.dataset.rod);
            updateRodGradient(rod, rodNum);
        });

        // Make toggle function available globally for testing/debugging
        window.toggle = toggle;

        // Pattern control
        let animationTimer = null;
        let currentPatternGenerator = null;
        let defaultPatternInterval = 500;

        function clearAllLights() {
            for (let i = 1; i <= 12; i++) {
                toggle(i, false);
                const checkbox = document.querySelector(`#led-${i}`);
                if (checkbox) checkbox.checked = false;
            }
        }

        function stopAnimation() {
            if (animationTimer) {
                clearTimeout(animationTimer);
                animationTimer = null;
            }
        }

        function applyPattern() {
            if (!currentPatternGenerator) return;

            // Get next pattern from generator
            const result = currentPatternGenerator.next();
            let patternString = result.value;
            let nextDelay = defaultPatternInterval;

            // Check if this is a tuple with timing information [pattern, delay]
            if (Array.isArray(patternString)) {
                [patternString, nextDelay] = patternString;
            }

            // Parse the pattern string, extracting only 0s and 1s
            const digits = patternString.replace(/[^01]/g, '');

            // Clear all lights first
            clearAllLights();

            // First 6 digits are top LEDs (1-6)
            // Next 6 digits are bottom LEDs (7-12)
            for (let i = 0; i < digits.length && i < 12; i++) {
                if (digits[i] === '1') {
                    const lightNumber = i + 1;
                    toggle(lightNumber, true);
                }
            }

            // Schedule next pattern application with variable delay
            if (currentPatternGenerator) {
                animationTimer = setTimeout(applyPattern, nextDelay);
            }
        }

        // Event listeners for pattern radio buttons
        const patternRadios = document.querySelectorAll('input[name="pattern"]');
        patternRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                stopAnimation();

                if (e.target.value === 'all-random') {
                    currentPatternGenerator = allRandomPatternTemplate();
                    defaultPatternInterval = 300;
                    applyPattern();
                } else if (e.target.value === 'bounce') {
                    currentPatternGenerator = bouncePatternTemplate();
                    defaultPatternInterval = 500;
                    applyPattern();
                } else if (e.target.value === 'random') {
                    currentPatternGenerator = randomPatternTemplate();
                    defaultPatternInterval = 1000;
                    applyPattern();
                } else if (e.target.value === 'wave') {
                    currentPatternGenerator = wavePatternTemplate();
                    defaultPatternInterval = 400;
                    applyPattern();
                } else if (e.target.value === 'snake') {
                    currentPatternGenerator = snakePatternTemplate();
                    defaultPatternInterval = 500;
                    applyPattern();
                } else if (e.target.value === 'sparkle') {
                    currentPatternGenerator = sparklePatternTemplate();
                    defaultPatternInterval = 300;
                    applyPattern();
                } else if (e.target.value === 'waterfall') {
                    currentPatternGenerator = waterfallPatternTemplate();
                    defaultPatternInterval = 200;
                    applyPattern();
                } else if (e.target.value === 'swizzle') {
                    currentPatternGenerator = swizzlePatternTemplate();
                    defaultPatternInterval = 300;
                    applyPattern();
                } else if (e.target.value === 'breathing') {
                    currentPatternGenerator = breathingPatternTemplate();
                    defaultPatternInterval = 300;
                    applyPattern();
                } else if (e.target.value === 'rule30') {
                    currentPatternGenerator = rule30PatternTemplate();
                    defaultPatternInterval = 400;
                    applyPattern();
                } else if (e.target.value === 'variableRule30') {
                    currentPatternGenerator = variableRule30PatternTemplate();
                    defaultPatternInterval = 400;
                    applyPattern();
                } else if (e.target.value === 'langton') {
                    currentPatternGenerator = langtonsAntPatternTemplate();
                    defaultPatternInterval = 250;
                    applyPattern();
                } else if (e.target.value === 'inverted-ant') {
                    currentPatternGenerator = invertedAntPatternTemplate();
                    defaultPatternInterval = 250;
                    applyPattern();
                } else if (e.target.value === 'heartbeat') {
                    currentPatternGenerator = heartbeatPatternTemplate();
                    defaultPatternInterval = 500;
                    applyPattern();
                } else if (e.target.value === 'thunder') {
                    currentPatternGenerator = thunderPatternTemplate();
                    defaultPatternInterval = 500;
                    applyPattern();
                } else if (e.target.value === 'explosion') {
                    currentPatternGenerator = explosionPatternTemplate();
                    defaultPatternInterval = 500;
                    applyPattern();
                } else if (e.target.value === 'none') {
                    // Just stop the animation, keep current light state
                    currentPatternGenerator = null;
                }
            });
        });
    </script>
</body>
</html>
